
from song_handler import Song
import soundfile as sf
import librosa
import numpy as np
import os
import matplotlib.pyplot as plt

FULL_WINDOW_SECONDS = 45
FADE_DURATION = 2.0
PLAYLIST = "yael_playlist"
songs_files_dir = "/vol/joberant_nobck/data/NLP_368307701_2324/yaelshemesh/"
np_files_dir = "/vol/joberant_nobck/data/NLP_368307701_2324/yaelshemesh/playlister_project/playlister_outputs_ofir/"
dtw_np_files_path = "/vol/joberant_nobck/data/NLP_368307701_2324/yaelshemesh/outputs/yael_playlist/dtw/"

def get_tempo_ratio_of_two_audios(audio1, audio2, sr):
    onset_env1 = librosa.onset.onset_strength(y=audio1, sr=sr,
                                         aggregate=np.median)
    tempo1, beats1 = librosa.beat.beat_track(onset_envelope=onset_env1,
                                           sr=sr)
    onset_env2 = librosa.onset.onset_strength(y=audio2, sr=sr,
                                         aggregate=np.median)
    tempo2, beats2 = librosa.beat.beat_track(onset_envelope=onset_env2,
                                           sr=sr)

    avg_tempo = (tempo1+tempo2)/2

    beats1 = librosa.frames_to_time(beats1, sr=sr)
    beats2 = librosa.frames_to_time(beats2, sr=sr)

    if len(beats1) > 0 and len(beats2) > 0:
        transition_beats_dist = beats2[0] + window - beats1[-1]
        expected_dist = avg_tempo/60
        real_dist_to_expected_dist_ratio = transition_beats_dist/expected_dist
    else:
        real_dist_to_expected_dist_ratio = 0
        print("couldn't find beats in one of the audios")

    if tempo1 == 0 or tempo2 == 0:
        print("tempo1 or tempo2 is 0")
        return 0.0, 0.0
#    print(type(tempo1/tempo2))
 #   print(type(real_dist_to_expected_dist_ratio))
    return tempo1/tempo2, real_dist_to_expected_dist_ratio

# ====================================================================================================
# Calculate tempo ratio and last to first beat distance ratio for all window pairs of all runs and output playlists:
# ====================================================================================================

window_pairs = [(200, 50), (200, 100), (250, 50), (250, 100), (250, 150)]
playlists_dict = {}


for window_size_samples_suffix, window_size_samples_prefix in window_pairs:
    np_files_path = os.path.join(np_files_dir, f"{PLAYLIST}/s_{int(window_size_samples_suffix*0.02)}_p_{int(window_size_samples_prefix*0.02)}")
    cut_indices_prefix = np.load(os.path.join(np_files_path, f"cut_indices_prefix_window_{window_size_samples_prefix}_hop_25.npy"))
    cut_indices_suffix = np.load(os.path.join(np_files_path, f"cut_indices_suffix_window_{window_size_samples_suffix}_hop_25.npy"))
    songs_name_order = np.load(os.path.join(np_files_path, "songs_name_order.npy"))
    adjecency_matrix = np.load(os.path.join(np_files_path, "adjacency_matrix.npy"))
    music_dir = os.path.join(songs_files_dir, PLAYLIST)
    songs_file_names_list = os.listdir(music_dir)

    order_songs_list = []
    for song_prefix_name in songs_name_order:
        for song_name in songs_file_names_list:
            if song_prefix_name == song_name.split(".")[0]:
                song = Song(os.path.join(music_dir, song_name))
                order_songs_list.append(song)
                break

    number_of_songs = len(order_songs_list)
    songs_time_len_after_cut = []
    songs_start_secs = []
    songs_end_secs = []
    for i in range(number_of_songs):
        start_sec = 0 if i == 0 else cut_indices_prefix[i-1, i]*0.02
        end_sec = 0 if i == number_of_songs-1 else - FULL_WINDOW_SECONDS + \
                                                        (cut_indices_suffix[i, i+1] +
                                                        window_size_samples_suffix) * 0.02
        end_sec = len(order_songs_list[i].audio)/order_songs_list[i].sr + end_sec
        song_time_after_cut = end_sec - start_sec
        songs_start_secs.append(start_sec)
        songs_end_secs.append(end_sec)
        songs_time_len_after_cut.append(song_time_after_cut)

    full_audio_transition_times = np.cumsum(songs_time_len_after_cut)
    playlists_dict[(window_size_samples_suffix, window_size_samples_prefix)] = \
        {"order_songs_list": order_songs_list,
            "songs_start_secs" : songs_start_secs,
            "songs_end_secs" : songs_end_secs,
            "full_audio_transition_times": full_audio_transition_times}



sr = playlists_dict[(200, 100)]["order_songs_list"][0].sr
window = 10

for playlist_key in playlists_dict.keys():
# Check beat distance for all songs transitions generated by MusicGen based solution:
    tempo_ratio_sum_mucic_gen = 0
    last_to_first_beat_distance_sum_music_gen = 0
    curr_playlist = playlists_dict[playlist_key]["order_songs_list"]
    curr_songs_end_secs = playlists_dict[playlist_key]["songs_end_secs"]
    curr_songs_start_secs = playlists_dict[playlist_key]["songs_start_secs"]
    for i in range(1, len(curr_playlist)):
        idx1 = i-1
        idx2 = i
        suffix_song1 = curr_playlist[idx1].get_partial_audio(start_sec=curr_songs_end_secs[idx1]-window,
                                                                end_sec=curr_songs_end_secs[idx1])
        prefix_song2 = curr_playlist[idx2].get_partial_audio(start_sec=curr_songs_start_secs[idx2],
                                                                end_sec=curr_songs_start_secs[idx2]+window)
        tempo_ratio, real_dist_to_expected_dist_ratio = get_tempo_ratio_of_two_audios(suffix_song1, prefix_song2, sr)
        tempo_ratio_sum_mucic_gen += tempo_ratio
        last_to_first_beat_distance_sum_music_gen += real_dist_to_expected_dist_ratio

    tempo_ratio_sum_mucic_gen /= len(curr_playlist) - 1 # average tempo ratio for all transitions
    last_to_first_beat_distance_sum_music_gen /= len(curr_playlist) - 1
    playlists_dict[playlist_key]["tempo_ratio_sum_mucic_gen"] = tempo_ratio_sum_mucic_gen
    playlists_dict[playlist_key]["last_to_first_beat_distance_sum_music_gen"] = last_to_first_beat_distance_sum_music_gen

# ====================================================================================================
# Calculate tempo ratio and last to first beat distance ratio for baseline DTW solution:
# ====================================================================================================

baseline_playlist_np = np.load(os.path.join(dtw_np_files_path, "baseline_playlister_playlist_numpy.npy"))
baseline_song_name_order = np.load(os.path.join(dtw_np_files_path, "baseline_songs_name_order.npy"))
baseline_best_cut_in_sec_tuples = np.load(os.path.join(dtw_np_files_path, "best_cuts_in_sec.npy"))
order_songs_list_dtw = []

for song_prefix_name in baseline_song_name_order:
    for song_name in songs_file_names_list:
        if song_prefix_name == song_name.split(".")[0]:
            song = Song(os.path.join(music_dir, song_name))
            order_songs_list_dtw.append(song)
            break

number_of_songs_dtw = len(order_songs_list_dtw)
songs_suffix_secs_dtw = []
songs_prefix_secs_dtw = []
songs_time_len_after_cut_dtw = []

for suffix_cut_time, prefix_cut_time in baseline_best_cut_in_sec_tuples:
    songs_suffix_secs_dtw.append(suffix_cut_time)
    songs_prefix_secs_dtw.append(prefix_cut_time)

full_audio_transition_times_dtw = np.cumsum(songs_time_len_after_cut_dtw)
songs_suffix_secs_dtw = np.array(songs_suffix_secs_dtw)
songs_suffix_secs_dtw_real = songs_suffix_secs_dtw[1:] - songs_suffix_secs_dtw[:-1]
songs_suffix_secs_dtw_real = np.concatenate([[songs_suffix_secs_dtw[0]], songs_suffix_secs_dtw_real])
songs_suffix_secs_dtw = np.concatenate([songs_suffix_secs_dtw_real, [len(order_songs_list_dtw[-1].audio)/sr]])
songs_prefix_secs_dtw = np.concatenate([[0], songs_prefix_secs_dtw])

window = 10
sr = order_songs_list_dtw[0].sr
tempo_ratio_sum_baseline = 0
beat_dist_sum_baseline = 0
for i in range(1, len(order_songs_list_dtw)):
    idx1 = i-1
    idx2 = i
    suffix_song1 = order_songs_list_dtw[idx1].get_partial_audio(start_sec=songs_suffix_secs_dtw[idx1]-window,
                                                            end_sec=songs_suffix_secs_dtw[idx1])
    prefix_song2 = order_songs_list_dtw[idx2].get_partial_audio(start_sec=songs_prefix_secs_dtw[idx2],
                                                            end_sec=songs_prefix_secs_dtw[idx2]+window)
    tempo_ratio, real_dist_to_expected_dist_ratio = get_tempo_ratio_of_two_audios(suffix_song1, prefix_song2, sr)

    tempo_ratio_sum_baseline += tempo_ratio
    beat_dist_sum_baseline += real_dist_to_expected_dist_ratio
tempo_ratio_sum_baseline /= len(order_songs_list_dtw) - 1
beat_dist_sum_baseline /= len(order_songs_list_dtw) - 1

# ====================================================================================================
# Calculate tempo ratio and last to first beat distance ratio for Random solution:
# ====================================================================================================
# Read all songs in the input path, shuffle their order randomly, and create a long audio with all of them concatenated    
# songs = []
# songs_end_secs = []
# songs_start_secs = []
# songs_start_secs = []
# songs_file_full_path = os.path.join(songs_files_dir, PLAYLIST)
# for song_name in os.listdir(songs_file_full_path):
#     songs.append(song)
#     songs_end_secs.append(song.audio.shape[0]/song.sr)
#     songs_start_secs.append(0 if len(songs_start_secs) == 0 else songs_end_secs[-2]) # 0 if first song, else the end of the previous song

# np.random.shuffle(songs)
# long_audio = np.concatenate([song.audio for song in songs])


# tempo_ratio_sum_random = 0
# last_to_first_beat_distance_sum_random = 0
# window = 10
# sr = songs[0].sr
# for i in range(1, len(songs)):
#     idx1 = i-1
#     idx2 = i
#     suffix_song1 = songs[idx1].get_partial_audio(start_sec=songs_end_secs[idx1]-window,
#                                                             end_sec=songs_end_secs[idx1])
#     prefix_song2 = songs[idx2].get_partial_audio(start_sec=songs_start_secs[idx2],
#                                                             end_sec=songs_start_secs[idx2]+window)
#     tempo_ratio, real_dist_to_expected_dist_ratio = get_tempo_ratio_of_two_audios(suffix_song1, prefix_song2, sr)
#     tempo_ratio = tempo_ratio if isinstance(tempo_ratio, float) else tempo_ratio[0]
#     real_dist_to_expected_dist_ratio = real_dist_to_expected_dist_ratio if isinstance(real_dist_to_expected_dist_ratio, float) else real_dist_to_expected_dist_ratio[0]
#     tempo_ratio_sum_random += tempo_ratio
#     last_to_first_beat_distance_sum_random += real_dist_to_expected_dist_ratio

# tempo_ratio_sum_random /= len(songs) - 1
# last_to_first_beat_distance_sum_random /= len(songs) - 1

# ====================================================================================================
# Plot bar chart of tempo ratio and last to first beat distance ratio for all results:
# ====================================================================================================

# Make Bar plot for tempo ratio next to last to first beat distance for all window pairs:
tempo_ratio_list = []
last_to_first_beat_distance_list = []

for playlist_key in playlists_dict.keys():
    tempo_ratio_list.append(playlists_dict[playlist_key]["tempo_ratio_sum_mucic_gen"][0])
    last_to_first_beat_distance_list.append(playlists_dict[playlist_key]["last_to_first_beat_distance_sum_music_gen"][0])
# add baseline results:
tempo_ratio_list.append(tempo_ratio_sum_baseline[0])
last_to_first_beat_distance_list.append(beat_dist_sum_baseline[0])
tempo_ratio_list.append(tempo_ratio_sum_random)
last_to_first_beat_distance_list.append(last_to_first_beat_distance_sum_random)

x = np.arange(len(window_pairs)+2)

print(x)
print(tempo_ratio_list)
print(last_to_first_beat_distance_list)

fig, ax = plt.subplots(layout='constrained')

bar_width = 0.25
rects = ax.bar(x, tempo_ratio_list, bar_width, label='Tempo Ratio')
ax.bar_label(rects, padding=3, fmt='%.2f')
rects = ax.bar(x + bar_width, last_to_first_beat_distance_list, bar_width, label='Last to First Beat Distance Ratio')
ax.bar_label(rects, padding=3, fmt='%.2f')
# ax.set_xlabel('Window Pairs')
ax.set_ylabel('Scores')
ax.set_title('Scores for all window pairs')
ax.set_xticks(x + bar_width, [f"{window_size_samples_suffix}, {window_size_samples_prefix}" for window_size_samples_suffix, window_size_samples_prefix in window_pairs]+["DTW", "Random"])
ax.set_ylim(0, 2)
ax.legend(loc='upper left')

plt.savefig("plot_tempo_bar_random_included.png")





